/*
 * Module code.
 *
 * Generated by SIP 4.9.1-snapshot-20091015 on Mon Mar 22 01:05:19 2010
 */

#include "sipAPIpy_sems_lib.h"

#line 5 "AmAudio.sip"
#include "../../../core/AmEvent.h"
#line 12 "sippy_sems_libcmodule.cpp"
#line 117 "PySemsB2ABDialog.sip"
#include "../PySemsB2ABDialog.h"
#line 15 "sippy_sems_libcmodule.cpp"
#line 81 "PySemsB2ABDialog.sip"
#include "../../../core/AmB2ABSession.h"
#line 18 "sippy_sems_libcmodule.cpp"
#line 6 "AmSipRequest.sip"
#include "../../../core/AmSipMsg.h"
#line 21 "sippy_sems_libcmodule.cpp"
#line 4 "string.sip"
#include <string>
using std::string;
#line 25 "sippy_sems_libcmodule.cpp"
#line 6 "AmSipReply.sip"
#include "../../../core/AmSipMsg.h"
#line 28 "sippy_sems_libcmodule.cpp"
#line 6 "AmSipDialog.sip"
#include "../../../core/AmSipDialog.h"
#line 31 "sippy_sems_libcmodule.cpp"

/* Define the strings used by this module. */
const char sipStrings_py_sems_lib[] = {
    'A', 'm', 'S', 'e', 's', 's', 'i', 'o', 'n', 'A', 'u', 'd', 'i', 'o', 'C', 'o', 'n', 'n', 'e', 'c', 't', 'o', 'r', 0,
    'A', 'm', 'A', 'u', 'd', 'i', 'o', 'E', 'v', 'e', 'n', 't', ':', ':', 'E', 'v', 'e', 'n', 't', 'T', 'y', 'p', 'e', 0,
    'P', 'y', 'S', 'e', 'm', 's', 'B', '2', 'A', 'B', 'C', 'a', 'l', 'l', 'e', 'e', 'D', 'i', 'a', 'l', 'o', 'g', 0,
    'A', 'm', 'A', 'u', 'd', 'i', 'o', 'F', 'i', 'l', 'e', ':', ':', 'O', 'p', 'e', 'n', 'M', 'o', 'd', 'e', 0,
    'A', 'm', 'B', '2', 'A', 'B', 'C', 'a', 'l', 'l', 'e', 'e', 'S', 'e', 's', 's', 'i', 'o', 'n', 0,
    'c', 'r', 'e', 'a', 't', 'e', 'C', 'a', 'l', 'l', 'e', 'e', 'S', 'e', 's', 's', 'i', 'o', 'n', 0,
    'A', 'm', 'S', 'i', 'p', 'D', 'i', 'a', 'l', 'o', 'g', ':', ':', 'S', 't', 'a', 't', 'u', 's', 0,
    'g', 'e', 't', 'U', 'A', 'C', 'T', 'r', 'a', 'n', 's', 'P', 'e', 'n', 'd', 'i', 'n', 'g', 0,
    'd', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'S', 'e', 's', 's', 'i', 'o', 'n', 0,
    'g', 'e', 't', '_', 'h', 'e', 'a', 'd', 'e', 'r', '_', 'p', 'a', 'r', 'a', 'm', 0,
    'P', 'y', 'S', 'e', 'm', 's', 'B', '2', 'A', 'B', 'D', 'i', 'a', 'l', 'o', 'g', 0,
    'n', 'e', 'x', 't', '_', 'r', 'e', 'q', 'u', 'e', 's', 't', '_', 'u', 'r', 'i', 0,
    'P', 'y', 'S', 'e', 'm', 's', 'B', '2', 'A', 'B', 'E', 'v', 'e', 'n', 't', 0,
    'g', 'e', 't', 'C', 'a', 'l', 'l', 'e', 'e', 'S', 't', 'a', 't', 'u', 's', 0,
    'P', 'y', 'S', 'e', 'm', 's', 'B', '2', 'B', 'D', 'i', 'a', 'l', 'o', 'g', 0,
    'o', 'n', 'S', 'e', 's', 's', 'i', 'o', 'n', 'S', 't', 'a', 'r', 't', 0,
    'o', 'n', 'P', 'y', 'B', '2', 'A', 'B', 'E', 'v', 'e', 'n', 't', 0,
    'c', 'o', 'n', 'n', 'e', 'c', 't', 'C', 'a', 'l', 'l', 'e', 'e', 0,
    'g', 'e', 't', 'C', 'o', 'n', 't', 'a', 'c', 't', 'H', 'd', 'r', 0,
    'D', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'n', 'g', 0,
    'w', 'a', 'i', 't', 'R', 'e', 'l', 'e', 'a', 's', 'e', 'd', 0,
    'P', 'y', 'S', 'e', 'm', 's', 'D', 'i', 'a', 'l', 'o', 'g', 0,
    'A', 'm', 'A', 'u', 'd', 'i', 'o', 'E', 'v', 'e', 'n', 't', 0,
    'u', 'p', 'd', 'a', 't', 'e', 'S', 't', 'a', 't', 'u', 's', 0,
    'r', 'e', 'm', 'o', 't', 'e', '_', 'p', 'a', 'r', 't', 'y', 0,
    'D', 'i', 's', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 0,
    'A', 'm', 'S', 'i', 'p', 'R', 'e', 'q', 'u', 'e', 's', 't', 0,
    'o', 'n', 'B', '2', 'A', 'B', 'E', 'v', 'e', 'n', 't', 0,
    'a', 'c', 'c', 'e', 'p', 't', 'A', 'u', 'd', 'i', 'o', 0,
    'g', 'e', 't', 'D', 'a', 't', 'a', 'S', 'i', 'z', 'e', 0,
    'A', 'm', 'A', 'u', 'd', 'i', 'o', 'F', 'i', 'l', 'e', 0,
    's', 'e', 'n', 'd', 'R', 'e', 'q', 'u', 'e', 's', 't', 0,
    'l', 'o', 'c', 'a', 'l', '_', 'p', 'a', 'r', 't', 'y', 0,
    'c', 'o', 'n', 't', 'a', 'c', 't', '_', 'u', 'r', 'i', 0,
    'A', 'm', 'S', 'i', 'p', 'D', 'i', 'a', 'l', 'o', 'g', 0,
    'p', 'y', '_', 's', 'e', 'm', 's', '_', 'l', 'i', 'b', 0,
    'r', 'e', 'l', 'a', 'y', 'E', 'v', 'e', 'n', 't', 0,
    's', 'e', 't', 'S', 't', 'o', 'p', 'p', 'e', 'd', 0,
    'r', 'e', 'm', 'o', 't', 'e', '_', 'u', 'r', 'i', 0,
    'r', 'e', 'm', 'o', 't', 'e', '_', 't', 'a', 'g', 0,
    'A', 'm', 'S', 'i', 'p', 'R', 'e', 'p', 'l', 'y', 0,
    's', 'e', 't', 'O', 'u', 't', 'p', 'u', 't', 0,
    'p', 'r', 'o', 'c', 'e', 's', 's', 'e', 'd', 0,
    'g', 'e', 't', 'S', 't', 'a', 't', 'u', 's', 0,
    'l', 'o', 'c', 'a', 'l', '_', 'u', 'r', 'i', 0,
    'C', 'o', 'n', 'n', 'e', 'c', 't', 'e', 'd', 0,
    'l', 'o', 'c', 'a', 'l', '_', 't', 'a', 'g', 0,
    'g', 'e', 't', 'H', 'e', 'a', 'd', 'e', 'r', 0,
    's', 'e', 't', 'I', 'n', 'O', 'u', 't', 0,
    's', 'e', 't', 'I', 'n', 'p', 'u', 't', 0,
    'o', 'n', 'C', 'a', 'n', 'c', 'e', 'l', 0,
    'o', 'n', 'I', 'n', 'v', 'i', 't', 'e', 0,
    'e', 'v', 'e', 'n', 't', '_', 'i', 'd', 0,
    'r', 'e', 'i', 'n', 'v', 'i', 't', 'e', 0,
    's', 'e', 't', 'R', 'o', 'u', 't', 'e', 0,
    'g', 'e', 't', 'R', 'o', 'u', 't', 'e', 0,
    's', 'i', 'p', '_', 'p', 'o', 'r', 't', 0,
    'n', 'e', 'x', 't', '_', 'h', 'o', 'p', 0,
    'f', 'r', 'o', 'm', '_', 't', 'a', 'g', 0,
    'f', 'r', 'o', 'm', '_', 'u', 'r', 'i', 0,
    'r', 'e', 'l', 'e', 'a', 's', 'e', 0,
    'p', 'r', 'o', 'c', 'e', 's', 's', 0,
    's', 'e', 't', 'L', 'o', 'o', 'p', 0,
    'g', 'e', 't', 'L', 'o', 'o', 'p', 0,
    'c', 'l', 'e', 'a', 'r', 'e', 'd', 0,
    'n', 'o', 'A', 'u', 'd', 'i', 'o', 0,
    'A', 'm', 'E', 'v', 'e', 'n', 't', 0,
    'o', 'n', 'D', 't', 'm', 'f', 0,
    'r', 'e', 'w', 'i', 'n', 'd', 0,
    'u', 'p', 'd', 'a', 't', 'e', 0,
    'c', 'a', 'n', 'c', 'e', 'l', 0,
    's', 'i', 'p', '_', 'i', 'p', 0,
    'r', 'e', 'a', 's', 'o', 'n', 0,
    't', 'o', '_', 't', 'a', 'g', 0,
    'c', 'a', 'l', 'l', 'i', 'd', 0,
    'd', 'o', 'm', 'a', 'i', 'n', 0,
    'm', 'e', 't', 'h', 'o', 'd', 0,
    's', 't', 'r', 'i', 'n', 'g', 0,
    'b', 'l', 'o', 'c', 'k', 0,
    'o', 'n', 'B', 'y', 'e', 0,
    'c', 'l', 'o', 's', 'e', 0,
    'W', 'r', 'i', 't', 'e', 0,
    'r', 'e', 'p', 'l', 'y', 0,
    'r', 'o', 'u', 't', 'e', 0,
    'r', '_', 'u', 'r', 'i', 0,
    'd', 's', 't', 'i', 'p', 0,
    'o', 'p', 'e', 'n', 0,
    'R', 'e', 'a', 'd', 0,
    'c', 'o', 'd', 'e', 0,
    'b', 'o', 'd', 'y', 0,
    'h', 'd', 'r', 's', 0,
    'c', 's', 'e', 'q', 0,
    'f', 'r', 'o', 'm', 0,
    'u', 's', 'e', 'r', 0,
    'd', 'l', 'g', 0,
    'b', 'y', 'e', 0,
    'c', 'm', 'd', 0,
    't', 'o', 0,
};

void sipVH_py_sems_lib_0(sip_gilstate_t sipGILState,PyObject *sipMethod,PySemsB2ABEvent *a0)
{
    PyObject *resObj = sipCallMethod(0,sipMethod,"D",a0,sipType_PySemsB2ABEvent,NULL);

    if (!resObj || sipParseResult(0,sipMethod,resObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(resObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

AmB2ABCalleeSession * sipVH_py_sems_lib_1(sip_gilstate_t sipGILState,PyObject *sipMethod)
{
    AmB2ABCalleeSession * sipRes = 0;
    PyObject *resObj = sipCallMethod(0,sipMethod,"");

    if (!resObj || sipParseResult(0,sipMethod,resObj,"D6",sipType_AmB2ABCalleeSession,&sipRes) < 0)
        PyErr_Print();

    Py_XDECREF(resObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)

    return sipRes;
}

void sipVH_py_sems_lib_2(sip_gilstate_t sipGILState,PyObject *sipMethod,AmEvent *a0)
{
    PyObject *resObj = sipCallMethod(0,sipMethod,"D",a0,sipType_AmEvent,NULL);

    if (!resObj || sipParseResult(0,sipMethod,resObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(resObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

void sipVH_py_sems_lib_3(sip_gilstate_t sipGILState,PyObject *sipMethod,int a0,int a1)
{
    PyObject *resObj = sipCallMethod(0,sipMethod,"ii",a0,a1);

    if (!resObj || sipParseResult(0,sipMethod,resObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(resObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

void sipVH_py_sems_lib_4(sip_gilstate_t sipGILState,PyObject *sipMethod,const AmSipRequest& a0)
{
    PyObject *resObj = sipCallMethod(0,sipMethod,"D",const_cast<AmSipRequest *>(&a0),sipType_AmSipRequest,NULL);

    if (!resObj || sipParseResult(0,sipMethod,resObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(resObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

void sipVH_py_sems_lib_5(sip_gilstate_t sipGILState,PyObject *sipMethod)
{
    PyObject *resObj = sipCallMethod(0,sipMethod,"");

    if (!resObj || sipParseResult(0,sipMethod,resObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(resObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}


extern "C" {static PyObject *func_get_header_param(PyObject *,PyObject *);}
static PyObject *func_get_header_param(PyObject *,PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        const string * a0;
        int a0State = 0;
        const string * a1;
        int a1State = 0;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"J1J1",sipType_string,&a0,&a0State,sipType_string,&a1,&a1State))
        {
            string *sipRes;

            sipRes = new string(get_header_param(*a0,*a1));

            sipReleaseType(const_cast<string *>(a0),sipType_string,a0State);
            sipReleaseType(const_cast<string *>(a1),sipType_string,a1State);

            return sipConvertFromNewType(sipRes,sipType_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipArgsParsed,sipName_get_header_param);

    return NULL;
}


extern "C" {static PyObject *func_getHeader(PyObject *,PyObject *);}
static PyObject *func_getHeader(PyObject *,PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        const string * a0;
        int a0State = 0;
        const string * a1;
        int a1State = 0;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"J1J1",sipType_string,&a0,&a0State,sipType_string,&a1,&a1State))
        {
            string *sipRes;

            sipRes = new string(getHeader(*a0,*a1));

            sipReleaseType(const_cast<string *>(a0),sipType_string,a0State);
            sipReleaseType(const_cast<string *>(a1),sipType_string,a1State);

            return sipConvertFromNewType(sipRes,sipType_string,NULL);
        }
    }

    {
        const string * a0;
        int a0State = 0;
        const string * a1;
        int a1State = 0;
        const string * a2;
        int a2State = 0;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"J1J1J1",sipType_string,&a0,&a0State,sipType_string,&a1,&a1State,sipType_string,&a2,&a2State))
        {
            string *sipRes;

            sipRes = new string(getHeader(*a0,*a1,*a2));

            sipReleaseType(const_cast<string *>(a0),sipType_string,a0State);
            sipReleaseType(const_cast<string *>(a1),sipType_string,a1State);
            sipReleaseType(const_cast<string *>(a2),sipType_string,a2State);

            return sipConvertFromNewType(sipRes,sipType_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipArgsParsed,sipName_getHeader);

    return NULL;
}


/* Convert to a sub-class if possible. */
extern "C" {static const sipTypeDef *sipSubClass_AmEvent(void **);}
static const sipTypeDef *sipSubClass_AmEvent(void **sipCppRet)
{
    AmEvent *sipCpp = reinterpret_cast<AmEvent *>(*sipCppRet);
    sipWrapperType *sipClass;

#line 15 "AmAudio.sip"
	if(dynamic_cast<AmAudioEvent*>(sipCpp)){
		sipClass = sipClass_AmAudioEvent;
	}
	else {
		sipClass = sipClass_AmEvent;
	}
#line 315 "sippy_sems_libcmodule.cpp"

    return (sipClass ? sipClass->type : 0);
}
static sipEnumTypeDef enumTypes[] = {
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_AmAudioFile__OpenMode, {0}}, sipNameNr_OpenMode, 2, NULL},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_AmAudioEvent__EventType, {0}}, sipNameNr_EventType, 0, NULL},
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_AmSipDialog__Status, {0}}, sipNameNr_Status, 7, NULL},
};


/*
 * This defines each type in this module.
 */
static sipTypeDef *typesTable[] = {
    &sipTypeDef_py_sems_lib_AmAudioEvent.ctd_base,
    &enumTypes[1].etd_base,
    &sipTypeDef_py_sems_lib_AmAudioFile.ctd_base,
    &enumTypes[0].etd_base,
    &sipTypeDef_py_sems_lib_AmB2ABCalleeSession.ctd_base,
    &sipTypeDef_py_sems_lib_AmEvent.ctd_base,
    &sipTypeDef_py_sems_lib_AmSessionAudioConnector.ctd_base,
    &sipTypeDef_py_sems_lib_AmSipDialog.ctd_base,
    &enumTypes[2].etd_base,
    &sipTypeDef_py_sems_lib_AmSipReply.ctd_base,
    &sipTypeDef_py_sems_lib_AmSipRequest.ctd_base,
    &sipTypeDef_py_sems_lib_PySemsB2ABCalleeDialog.ctd_base,
    &sipTypeDef_py_sems_lib_PySemsB2ABDialog.ctd_base,
    &sipTypeDef_py_sems_lib_PySemsB2ABEvent.ctd_base,
    &sipTypeDef_py_sems_lib_PySemsB2BDialog.ctd_base,
    &sipTypeDef_py_sems_lib_PySemsDialog.ctd_base,
    &sipTypeDef_py_sems_lib_string.mtd_base,
};


/*
 * This defines the virtual handlers that this module implements and can be
 * used by other modules.
 */
static sipVirtHandlerFunc virtHandlersTable[] = {
    (sipVirtHandlerFunc)sipVH_py_sems_lib_0,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_1,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_2,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_3,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_4,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_5,
};


/* This defines the class sub-convertors that this module defines. */
static sipSubClassConvertorDef convertorsTable[] = {
    {sipSubClass_AmEvent, {5, 255, 0}, NULL},
    {NULL, {0, 0, 0}, NULL}
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI_py_sems_lib = {
    0,
    SIP_API_MINOR_NR,
    sipNameNr_py_sems_lib,
    0,
    0,
    sipStrings_py_sems_lib,
    NULL,
    NULL,
    17,
    typesTable,
    NULL,
    0,
    NULL,
    0,
    NULL,
    virtHandlersTable,
    convertorsTable,
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI_py_sems_lib;


/* The Python module initialisation function. */
#if PY_MAJOR_VERSION >= 3
#define SIP_MODULE_ENTRY        PyInit_py_sems_lib
#define SIP_MODULE_TYPE         PyObject *
#define SIP_MODULE_DISCARD(r)   Py_DECREF(r)
#define SIP_MODULE_RETURN(r)    return (r)
#else
#define SIP_MODULE_ENTRY        initpy_sems_lib
#define SIP_MODULE_TYPE         void
#define SIP_MODULE_DISCARD(r)
#define SIP_MODULE_RETURN(r)    return
#endif

#if defined(SIP_STATIC_MODULE)
extern "C" SIP_MODULE_TYPE SIP_MODULE_ENTRY()
#else
PyMODINIT_FUNC SIP_MODULE_ENTRY()
#endif
{
    static PyMethodDef sip_methods[] = {
        {SIP_MLNAME_CAST(sipName_get_header_param), func_get_header_param, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_getHeader), func_getHeader, METH_VARARGS, NULL},
        {0, 0, 0, 0}
    };

#if PY_MAJOR_VERSION >= 3
    static PyModuleDef sip_module_def = {
        PyModuleDef_HEAD_INIT,
        "py_sems_lib",
        NULL,
        -1,
        sip_methods,
        NULL,
        NULL,
        NULL,
        NULL
    };
#endif

    PyObject *sipModule, *sipModuleDict;
    PyObject *sip_sipmod, *sip_capiobj;

    /* Initialise the module and get it's dictionary. */
#if PY_MAJOR_VERSION >= 3
    sipModule = PyModule_Create(&sip_module_def);
#elif PY_VERSION_HEX >= 0x02050000
    sipModule = Py_InitModule(sipName_py_sems_lib, sip_methods);
#else
    sipModule = Py_InitModule(const_cast<char *>(sipName_py_sems_lib), sip_methods);
#endif

    if (sipModule == NULL)
        SIP_MODULE_RETURN(NULL);

    sipModuleDict = PyModule_GetDict(sipModule);

    /* Import the SIP module and get it's API. */
#if PY_VERSION_HEX >= 0x02050000
    sip_sipmod = PyImport_ImportModule("sip");
#else
    sip_sipmod = PyImport_ImportModule(const_cast<char *>("sip"));
#endif

    if (sip_sipmod == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod), "_C_API");

    if (sip_capiobj == NULL || !PyCObject_Check(sip_capiobj))
    {
        Py_DECREF(sip_sipmod);
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

    sipAPI_py_sems_lib = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));

    /* Export the module and publish it's API. */
    if (sipExportModule(&sipModuleAPI_py_sems_lib,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,0) < 0)
    {
        Py_DECREF(sip_sipmod);
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }
    /* Initialise the module now all its dependencies have been set up. */
    if (sipInitModule(&sipModuleAPI_py_sems_lib,sipModuleDict) < 0)
    {
        Py_DECREF(sip_sipmod);
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }

    SIP_MODULE_RETURN(sipModule);
}
