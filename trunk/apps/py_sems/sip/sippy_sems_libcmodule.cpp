/*
 * Module code.
 *
 * Generated by SIP 4.5.2 (4.5.2) on Mon Dec  8 15:20:56 2008
 */

#include "sipAPIpy_sems_lib.h"

#include "sippy_sems_libPySemsB2ABEvent.h"
#include "sippy_sems_libPySemsB2ABCalleeDialog.h"
#include "sippy_sems_libAmB2ABCalleeSession.h"
#include "sippy_sems_libPySemsB2ABDialog.h"
#include "sippy_sems_libAmSessionAudioConnector.h"
#include "sippy_sems_libPySemsB2BDialog.h"
#include "sippy_sems_libPySemsDialog.h"
#include "sippy_sems_libAmAudioFile.h"
#include "sippy_sems_libAmAudioEvent.h"
#include "sippy_sems_libAmEvent.h"
#include "sippy_sems_libAmSipDialog.h"
#include "sippy_sems_libAmSipReply.h"
#include "sippy_sems_libAmSipRequest.h"
#include "sippy_sems_libstring.h"


/* Define the strings used by this module. */
char sipNm_py_sems_lib_get_header_param[] = "get_header_param";
char sipNm_py_sems_lib_PySemsB2ABEvent[] = "PySemsB2ABEvent";
char sipNm_py_sems_lib_onPyB2ABEvent[] = "onPyB2ABEvent";
char sipNm_py_sems_lib_PySemsB2ABCalleeDialog[] = "PySemsB2ABCalleeDialog";
char sipNm_py_sems_lib_AmB2ABCalleeSession[] = "AmB2ABCalleeSession";
char sipNm_py_sems_lib_relayEvent[] = "relayEvent";
char sipNm_py_sems_lib_onB2ABEvent[] = "onB2ABEvent";
char sipNm_py_sems_lib_createCalleeSession[] = "createCalleeSession";
char sipNm_py_sems_lib_getCalleeStatus[] = "getCalleeStatus";
char sipNm_py_sems_lib_disconnectSession[] = "disconnectSession";
char sipNm_py_sems_lib_connectSession[] = "connectSession";
char sipNm_py_sems_lib_connectCallee[] = "connectCallee";
char sipNm_py_sems_lib_PySemsB2ABDialog[] = "PySemsB2ABDialog";
char sipNm_py_sems_lib_waitReleased[] = "waitReleased";
char sipNm_py_sems_lib_release[] = "release";
char sipNm_py_sems_lib_block[] = "block";
char sipNm_py_sems_lib_AmSessionAudioConnector[] = "AmSessionAudioConnector";
char sipNm_py_sems_lib_PySemsB2BDialog[] = "PySemsB2BDialog";
char sipNm_py_sems_lib_process[] = "process";
char sipNm_py_sems_lib_setInOut[] = "setInOut";
char sipNm_py_sems_lib_setOutput[] = "setOutput";
char sipNm_py_sems_lib_setInput[] = "setInput";
char sipNm_py_sems_lib_onDtmf[] = "onDtmf";
char sipNm_py_sems_lib_onBye[] = "onBye";
char sipNm_py_sems_lib_onCancel[] = "onCancel";
char sipNm_py_sems_lib_onSessionStart[] = "onSessionStart";
char sipNm_py_sems_lib_onInvite[] = "onInvite";
char sipNm_py_sems_lib_setStopped[] = "setStopped";
char sipNm_py_sems_lib_acceptAudio[] = "acceptAudio";
char sipNm_py_sems_lib_dlg[] = "dlg";
char sipNm_py_sems_lib_PySemsDialog[] = "PySemsDialog";
char sipNm_py_sems_lib_getDataSize[] = "getDataSize";
char sipNm_py_sems_lib_close[] = "close";
char sipNm_py_sems_lib_rewind[] = "rewind";
char sipNm_py_sems_lib_open[] = "open";
char sipNm_py_sems_lib_setLoop[] = "setLoop";
char sipNm_py_sems_lib_getLoop[] = "getLoop";
char sipNm_py_sems_lib_Write[] = "Write";
char sipNm_py_sems_lib_Read[] = "Read";
char sipNm_py_sems_lib_AmAudioFile[] = "AmAudioFile";
char sipNm_py_sems_lib_cleared[] = "cleared";
char sipNm_py_sems_lib_noAudio[] = "noAudio";
char sipNm_py_sems_lib_AmAudioEvent[] = "AmAudioEvent";
char sipNm_py_sems_lib_processed[] = "processed";
char sipNm_py_sems_lib_event_id[] = "event_id";
char sipNm_py_sems_lib_AmEvent[] = "AmEvent";
char sipNm_py_sems_lib_reinvite[] = "reinvite";
char sipNm_py_sems_lib_update[] = "update";
char sipNm_py_sems_lib_cancel[] = "cancel";
char sipNm_py_sems_lib_bye[] = "bye";
char sipNm_py_sems_lib_sendRequest[] = "sendRequest";
char sipNm_py_sems_lib_reply[] = "reply";
char sipNm_py_sems_lib_updateStatus[] = "updateStatus";
char sipNm_py_sems_lib_getContactHdr[] = "getContactHdr";
char sipNm_py_sems_lib_getStatus[] = "getStatus";
char sipNm_py_sems_lib_getUACTransPending[] = "getUACTransPending";
char sipNm_py_sems_lib_setRoute[] = "setRoute";
char sipNm_py_sems_lib_getRoute[] = "getRoute";
char sipNm_py_sems_lib_local_party[] = "local_party";
char sipNm_py_sems_lib_remote_party[] = "remote_party";
char sipNm_py_sems_lib_contact_uri[] = "contact_uri";
char sipNm_py_sems_lib_remote_uri[] = "remote_uri";
char sipNm_py_sems_lib_local_uri[] = "local_uri";
char sipNm_py_sems_lib_sip_port[] = "sip_port";
char sipNm_py_sems_lib_sip_ip[] = "sip_ip";
char sipNm_py_sems_lib_Disconnecting[] = "Disconnecting";
char sipNm_py_sems_lib_Connected[] = "Connected";
char sipNm_py_sems_lib_Pending[] = "Pending";
char sipNm_py_sems_lib_Disconnected[] = "Disconnected";
char sipNm_py_sems_lib_AmSipDialog[] = "AmSipDialog";
char sipNm_py_sems_lib_local_tag[] = "local_tag";
char sipNm_py_sems_lib_remote_tag[] = "remote_tag";
char sipNm_py_sems_lib_next_request_uri[] = "next_request_uri";
char sipNm_py_sems_lib_reason[] = "reason";
char sipNm_py_sems_lib_code[] = "code";
char sipNm_py_sems_lib_AmSipReply[] = "AmSipReply";
char sipNm_py_sems_lib_getHeader[] = "getHeader";
char sipNm_py_sems_lib_next_hop[] = "next_hop";
char sipNm_py_sems_lib_route[] = "route";
char sipNm_py_sems_lib_body[] = "body";
char sipNm_py_sems_lib_hdrs[] = "hdrs";
char sipNm_py_sems_lib_cseq[] = "cseq";
char sipNm_py_sems_lib_to_tag[] = "to_tag";
char sipNm_py_sems_lib_from_tag[] = "from_tag";
char sipNm_py_sems_lib_callid[] = "callid";
char sipNm_py_sems_lib_to[] = "to";
char sipNm_py_sems_lib_from[] = "from";
char sipNm_py_sems_lib_from_uri[] = "from_uri";
char sipNm_py_sems_lib_r_uri[] = "r_uri";
char sipNm_py_sems_lib_port[] = "port";
char sipNm_py_sems_lib_dstip[] = "dstip";
char sipNm_py_sems_lib_domain[] = "domain";
char sipNm_py_sems_lib_user[] = "user";
char sipNm_py_sems_lib_method[] = "method";
char sipNm_py_sems_lib_cmd[] = "cmd";
char sipNm_py_sems_lib_AmSipRequest[] = "AmSipRequest";
char sipNm_py_sems_lib_string[] = "string";

void sipVH_py_sems_lib_0(sip_gilstate_t sipGILState,PyObject *sipMethod,PySemsB2ABEvent *a0)
{
    PyObject *sipResObj = sipCallMethod(0,sipMethod,"C",a0,sipClass_PySemsB2ABEvent,NULL);

    if (!sipResObj || sipParseResult(0,sipMethod,sipResObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(sipResObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

AmB2ABCalleeSession * sipVH_py_sems_lib_1(sip_gilstate_t sipGILState,PyObject *sipMethod)
{
    AmB2ABCalleeSession * sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0,sipMethod,"");

    if (!sipResObj || sipParseResult(0,sipMethod,sipResObj,"C6",sipClass_AmB2ABCalleeSession,&sipRes) < 0)
        PyErr_Print();

    Py_XDECREF(sipResObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)

    return sipRes;
}

void sipVH_py_sems_lib_2(sip_gilstate_t sipGILState,PyObject *sipMethod,AmEvent *a0)
{
    PyObject *sipResObj = sipCallMethod(0,sipMethod,"C",a0,sipClass_AmEvent,NULL);

    if (!sipResObj || sipParseResult(0,sipMethod,sipResObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(sipResObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

void sipVH_py_sems_lib_3(sip_gilstate_t sipGILState,PyObject *sipMethod,int a0,int a1)
{
    PyObject *sipResObj = sipCallMethod(0,sipMethod,"ii",a0,a1);

    if (!sipResObj || sipParseResult(0,sipMethod,sipResObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(sipResObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

void sipVH_py_sems_lib_4(sip_gilstate_t sipGILState,PyObject *sipMethod,const AmSipRequest& a0)
{
    PyObject *sipResObj = sipCallMethod(0,sipMethod,"C",const_cast<AmSipRequest *>(&a0),sipClass_AmSipRequest,NULL);

    if (!sipResObj || sipParseResult(0,sipMethod,sipResObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(sipResObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}

void sipVH_py_sems_lib_5(sip_gilstate_t sipGILState,PyObject *sipMethod)
{
    PyObject *sipResObj = sipCallMethod(0,sipMethod,"");

    if (!sipResObj || sipParseResult(0,sipMethod,sipResObj,"Z") < 0)
        PyErr_Print();

    Py_XDECREF(sipResObj);
    Py_DECREF(sipMethod);

    SIP_RELEASE_GIL(sipGILState)
}


extern "C" {static PyObject *func_get_header_param(PyObject *,PyObject *);}
static PyObject *func_get_header_param(PyObject *,PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        const string * a0;
        int a0State = 0;
        const string * a1;
        int a1State = 0;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"M1M1",sipMappedType_string,&a0,&a0State,sipMappedType_string,&a1,&a1State))
        {
            string *sipRes;

            sipRes = new string(get_header_param(*a0,*a1));

            sipReleaseMappedType(const_cast<string *>(a0),sipMappedType_string,a0State);
            sipReleaseMappedType(const_cast<string *>(a1),sipMappedType_string,a1State);

            PyObject *sipResObj = sipConvertFromMappedType(sipRes,sipMappedType_string,NULL);
            delete sipRes;

            return sipResObj;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipArgsParsed,sipNm_py_sems_lib_get_header_param);

    return NULL;
}


extern "C" {static PyObject *func_getHeader(PyObject *,PyObject *);}
static PyObject *func_getHeader(PyObject *,PyObject *sipArgs)
{
    int sipArgsParsed = 0;

    {
        const string * a0;
        int a0State = 0;
        const string * a1;
        int a1State = 0;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"M1M1",sipMappedType_string,&a0,&a0State,sipMappedType_string,&a1,&a1State))
        {
            string *sipRes;

            sipRes = new string(getHeader(*a0,*a1));

            sipReleaseMappedType(const_cast<string *>(a0),sipMappedType_string,a0State);
            sipReleaseMappedType(const_cast<string *>(a1),sipMappedType_string,a1State);

            PyObject *sipResObj = sipConvertFromMappedType(sipRes,sipMappedType_string,NULL);
            delete sipRes;

            return sipResObj;
        }
    }

    {
        const string * a0;
        int a0State = 0;
        const string * a1;
        int a1State = 0;
        const string * a2;
        int a2State = 0;

        if (sipParseArgs(&sipArgsParsed,sipArgs,"M1M1M1",sipMappedType_string,&a0,&a0State,sipMappedType_string,&a1,&a1State,sipMappedType_string,&a2,&a2State))
        {
            string *sipRes;

            sipRes = new string(getHeader(*a0,*a1,*a2));

            sipReleaseMappedType(const_cast<string *>(a0),sipMappedType_string,a0State);
            sipReleaseMappedType(const_cast<string *>(a1),sipMappedType_string,a1State);
            sipReleaseMappedType(const_cast<string *>(a2),sipMappedType_string,a2State);

            PyObject *sipResObj = sipConvertFromMappedType(sipRes,sipMappedType_string,NULL);
            delete sipRes;

            return sipResObj;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipArgsParsed,sipNm_py_sems_lib_getHeader);

    return NULL;
}


/* Convert to a sub-class if possible. */
extern "C" {static sipWrapperType *sipSubClass_AmEvent(void **);}
static sipWrapperType *sipSubClass_AmEvent(void **sipCppRet)
{
    AmEvent *sipCpp = reinterpret_cast<AmEvent *>(*sipCppRet);
    sipWrapperType *sipClass;

#line 15 "AmAudio.sip"
	if(dynamic_cast<AmAudioEvent*>(sipCpp)){
		sipClass = sipClass_AmAudioEvent;
	}
	else {
		sipClass = sipClass_AmEvent;
	}
#line 314 "sippy_sems_libcmodule.cpp"

    return sipClass;
}


/*
 * This defines each class in this module.  The values are replaced by the
 * proper Python types during the export process.
 */
static sipWrapperType *typesTable[] = {
    (sipWrapperType *)(void *)&sipType_py_sems_lib_PySemsB2ABEvent,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmB2ABCalleeSession,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_PySemsB2ABCalleeDialog,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_PySemsB2ABDialog,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmSessionAudioConnector,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_PySemsB2BDialog,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_PySemsDialog,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmAudioFile,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmEvent,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmAudioEvent,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmSipDialog,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmSipReply,
    (sipWrapperType *)(void *)&sipType_py_sems_lib_AmSipRequest,
};


/* This defines each mapped type in this module. */
static sipMappedType *mappedTypesTable[] = {
    &sipMappedTypeDef_string,
    0
};


/* Define each named enum in this module. */
static sipEnumDef enumTypesTable[] = {
    {"py_sems_lib.AmAudioFile.OpenMode", NULL, 7, NULL},
    {"py_sems_lib.AmAudioEvent.EventType", NULL, 9, NULL},
    {"py_sems_lib.AmSipDialog.Status", NULL, 10, NULL},
};


/*
 * This defines the virtual handlers that this module implements and can be
 * used by other modules.
 */
static sipVirtHandlerFunc virtHandlersTable[] = {
    (sipVirtHandlerFunc)sipVH_py_sems_lib_0,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_1,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_2,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_3,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_4,
    (sipVirtHandlerFunc)sipVH_py_sems_lib_5,
};


/* This defines the class sub-convertors that this module defines. */
static sipSubClassConvertorDef convertorsTable[] = {
    {sipSubClass_AmEvent, {8, 255, 0}, NULL},
    {NULL, {0, 0, 0}, NULL}
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI_py_sems_lib = {
    NULL,
    SIP_API_MINOR_NR,
    "py_sems_lib",
    NULL,
    0,
    NULL,
    NULL,
    13,
    typesTable,
    NULL,
    mappedTypesTable,
    3,
    NULL,
    enumTypesTable,
    0,
    NULL,
    NULL,
    virtHandlersTable,
    convertorsTable,
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI_py_sems_lib;


/* The Python module initialisation function. */
#if defined(SIP_STATIC_MODULE)
extern "C" void initpy_sems_lib()
#else
PyMODINIT_FUNC initpy_sems_lib()
#endif
{
   static PyMethodDef sip_methods[] = {
        {sipNm_py_sems_lib_get_header_param, func_get_header_param, METH_VARARGS, NULL},
        {sipNm_py_sems_lib_getHeader, func_getHeader, METH_VARARGS, NULL},
        {0, 0, 0, 0}
    };

   PyObject *sipModule, *sipModuleDict, *sip_sipmod, *sip_capiobj;

    /* Initialise the module and get it's dictionary. */
    sipModule = Py_InitModule((char *)sipModuleAPI_py_sems_lib.em_name,sip_methods);
    sipModuleDict = PyModule_GetDict(sipModule);

    /* Import the SIP module and get it's API. */
    sip_sipmod = PyImport_ImportModule((char *)"sip");

    if (sip_sipmod == NULL)
        return;

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod),"_C_API");

    if (sip_capiobj == NULL || !PyCObject_Check(sip_capiobj))
        return;

    sipAPI_py_sems_lib = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));

    /* Export the module and publish it's API. */
    if (sipAPI_py_sems_lib->api_export_module(&sipModuleAPI_py_sems_lib,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,sipModuleDict) < 0)
       return;
}
