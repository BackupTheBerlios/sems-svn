/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.1.1 (4.1.1-255) on Fri Feb 16 10:10:16 2007
 */

#include "sipAPIpy_sems_lib.h"
#include "sippy_sems_libAmSipReply.h"


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
static void *cast_AmSipReply(void *ptr,sipWrapperType *targetClass)
{
	if (targetClass == sipClass_AmSipReply)
		return ptr;

	return NULL;
}


static void dealloc_AmSipReply(sipWrapper *sipSelf)
{
	if (sipIsPyOwned(sipSelf))
	{
		delete reinterpret_cast<AmSipReply *>(sipSelf -> u.cppPtr);
	}
}


static void *init_AmSipReply(sipWrapper *,PyObject *sipArgs,int *)
{
	int sipArgsParsed = 0;
	AmSipReply *sipCpp = 0;

	if (!sipCpp)
	{
		if (sipParseArgs(&sipArgsParsed,sipArgs,""))
		{
			sipCpp = new AmSipReply();
		}
	}

	if (!sipCpp)
	{
		const AmSipReply * a0;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"J1",sipClass_AmSipReply,&a0))
		{
			sipCpp = new AmSipReply(*a0);
		}
	}

	if (!sipCpp)
	{
		sipNoCtor(sipArgsParsed,sipNm_py_sems_lib_AmSipReply);
		return 0;
	}

	return sipCpp;
}


static PyObject *var_AmSipReply_cseq(PyObject *sipSelf,PyObject *valobj)
{
	unsigned val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = sipCpp -> cseq;

		valobj = PyInt_FromLong((long)val);

		return valobj;
	}

	val = (unsigned)PyInt_AsLong(valobj);

	if (PyErr_Occurred() != NULL)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_cseq);
		return NULL;
	}

	sipCpp -> cseq = val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_local_tag(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> local_tag;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_local_tag);
		return NULL;
	}

	sipCpp -> local_tag = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_remote_tag(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> remote_tag;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_remote_tag);
		return NULL;
	}

	sipCpp -> remote_tag = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_body(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> body;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_body);
		return NULL;
	}

	sipCpp -> body = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_hdrs(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> hdrs;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_hdrs);
		return NULL;
	}

	sipCpp -> hdrs = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_route(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> route;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_route);
		return NULL;
	}

	sipCpp -> route = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_next_hop(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> next_hop;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_next_hop);
		return NULL;
	}

	sipCpp -> next_hop = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_next_request_uri(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> next_request_uri;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_next_request_uri);
		return NULL;
	}

	sipCpp -> next_request_uri = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_reason(PyObject *sipSelf,PyObject *valobj)
{
	int iserr = 0;
	string *val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = &sipCpp -> reason;

		valobj = sipConvertFrom_string(val);

		return valobj;
	}

	val = reinterpret_cast<string *>(sipForceConvertTo_string(valobj,&iserr));

	if (iserr)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_reason);
		return NULL;
	}

	sipCpp -> reason = *val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmSipReply_code(PyObject *sipSelf,PyObject *valobj)
{
	unsigned val;
	AmSipReply *sipCpp = reinterpret_cast<AmSipReply *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmSipReply));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = sipCpp -> code;

		valobj = PyInt_FromLong((long)val);

		return valobj;
	}

	val = (unsigned)PyInt_AsLong(valobj);

	if (PyErr_Occurred() != NULL)
	{
		sipBadSetType(sipNm_py_sems_lib_AmSipReply,sipNm_py_sems_lib_code);
		return NULL;
	}

	sipCpp -> code = val;

	Py_INCREF(Py_None);
	return Py_None;
}

PyMethodDef variables_AmSipReply[] = {
	{sipNm_py_sems_lib_cseq, var_AmSipReply_cseq, 0, NULL},
	{sipNm_py_sems_lib_local_tag, var_AmSipReply_local_tag, 0, NULL},
	{sipNm_py_sems_lib_remote_tag, var_AmSipReply_remote_tag, 0, NULL},
	{sipNm_py_sems_lib_body, var_AmSipReply_body, 0, NULL},
	{sipNm_py_sems_lib_hdrs, var_AmSipReply_hdrs, 0, NULL},
	{sipNm_py_sems_lib_route, var_AmSipReply_route, 0, NULL},
	{sipNm_py_sems_lib_next_hop, var_AmSipReply_next_hop, 0, NULL},
	{sipNm_py_sems_lib_next_request_uri, var_AmSipReply_next_request_uri, 0, NULL},
	{sipNm_py_sems_lib_reason, var_AmSipReply_reason, 0, NULL},
	{sipNm_py_sems_lib_code, var_AmSipReply_code, 0, NULL},
	{0, 0, 0, 0}
};


static void *forceConvertTo_AmSipReply(PyObject *valobj,int *iserrp)
{
	if (*iserrp || valobj == NULL)
		return NULL;

	if (valobj == Py_None || sipIsSubClassInstance(valobj,sipClass_AmSipReply))
		return sipConvertToCpp(valobj,sipClass_AmSipReply,iserrp);

	sipBadClass(sipNm_py_sems_lib_AmSipReply);

	*iserrp = 1;

	return NULL;
}


/* The main type data structure. */
sipTypeDef sipType_AmSipReply = {
	0,
	"py_sems_lib.AmSipReply",
	-1,
	0,
	0,
	0, 0,
	0, 0,
	variables_AmSipReply,
	init_AmSipReply,
	dealloc_AmSipReply,
	cast_AmSipReply,
	forceConvertTo_AmSipReply,
	0,
	0,
	0,
	{0, 0, 0, 0, 0, 0}
};
