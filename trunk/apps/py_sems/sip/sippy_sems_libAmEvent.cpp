/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.1.1 (4.1.1-255) on Mon Feb 19 14:57:35 2007
 */

#include "sipAPIpy_sems_lib.h"
#include "sippy_sems_libAmEvent.h"

sipAmEvent::sipAmEvent(int a0): AmEvent(a0), sipPySelf(0)
{
	sipCommonCtor(NULL,0);
}

sipAmEvent::sipAmEvent(const AmEvent& a0): AmEvent(a0), sipPySelf(0)
{
	sipCommonCtor(NULL,0);
}

sipAmEvent::~sipAmEvent()
{
	sipCommonDtor(sipPySelf);
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
static void *cast_AmEvent(void *ptr,sipWrapperType *targetClass)
{
	if (targetClass == sipClass_AmEvent)
		return ptr;

	return NULL;
}


static void dealloc_AmEvent(sipWrapper *sipSelf)
{
	if (!sipIsSimple(sipSelf))
		reinterpret_cast<sipAmEvent *>(sipSelf -> u.cppPtr) -> sipPySelf = NULL;

	if (sipIsPyOwned(sipSelf))
	{
		if (!sipIsSimple(sipSelf))
			delete reinterpret_cast<sipAmEvent *>(sipSelf -> u.cppPtr);
		else
			delete reinterpret_cast<AmEvent *>(sipSelf -> u.cppPtr);
	}
}


static void *init_AmEvent(sipWrapper *sipSelf,PyObject *sipArgs,int *)
{
	int sipArgsParsed = 0;
	sipAmEvent *sipCpp = 0;

	if (!sipCpp)
	{
		int a0;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"i",&a0))
		{
			sipCpp = new sipAmEvent(a0);
		}
	}

	if (!sipCpp)
	{
		const AmEvent * a0;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"J1",sipClass_AmEvent,&a0))
		{
			sipCpp = new sipAmEvent(*a0);
		}
	}

	if (!sipCpp)
	{
		sipNoCtor(sipArgsParsed,sipNm_py_sems_lib_AmEvent);
		return 0;
	}

	sipCpp -> sipPySelf = sipSelf;

	return sipCpp;
}


static PyObject *var_AmEvent_processed(PyObject *sipSelf,PyObject *valobj)
{
	bool val;
	AmEvent *sipCpp = reinterpret_cast<AmEvent *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmEvent));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = sipCpp -> processed;

		valobj = PyBool_FromLong(val);

		return valobj;
	}

	val = (bool)PyInt_AsLong(valobj);

	if (PyErr_Occurred() != NULL)
	{
		sipBadSetType(sipNm_py_sems_lib_AmEvent,sipNm_py_sems_lib_processed);
		return NULL;
	}

	sipCpp -> processed = val;

	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *var_AmEvent_event_id(PyObject *sipSelf,PyObject *valobj)
{
	int val;
	AmEvent *sipCpp = reinterpret_cast<AmEvent *>(sipGetCppPtr((sipWrapper *)sipSelf,sipClass_AmEvent));

	if (!sipCpp)
		return NULL;

	if (valobj == NULL)
	{
		val = sipCpp -> event_id;

		valobj = PyInt_FromLong((long)val);

		return valobj;
	}

	val = (int)PyInt_AsLong(valobj);

	if (PyErr_Occurred() != NULL)
	{
		sipBadSetType(sipNm_py_sems_lib_AmEvent,sipNm_py_sems_lib_event_id);
		return NULL;
	}

	sipCpp -> event_id = val;

	Py_INCREF(Py_None);
	return Py_None;
}

PyMethodDef variables_AmEvent[] = {
	{sipNm_py_sems_lib_processed, var_AmEvent_processed, 0, NULL},
	{sipNm_py_sems_lib_event_id, var_AmEvent_event_id, 0, NULL},
	{0, 0, 0, 0}
};


static void *forceConvertTo_AmEvent(PyObject *valobj,int *iserrp)
{
	if (*iserrp || valobj == NULL)
		return NULL;

	if (valobj == Py_None || sipIsSubClassInstance(valobj,sipClass_AmEvent))
		return sipConvertToCpp(valobj,sipClass_AmEvent,iserrp);

	sipBadClass(sipNm_py_sems_lib_AmEvent);

	*iserrp = 1;

	return NULL;
}


/* The main type data structure. */
sipTypeDef sipType_AmEvent = {
	0,
	"py_sems_lib.AmEvent",
	-1,
	0,
	0,
	0, 0,
	0, 0,
	variables_AmEvent,
	init_AmEvent,
	dealloc_AmEvent,
	cast_AmEvent,
	forceConvertTo_AmEvent,
	0,
	0,
	0,
	{0, 0, 0, 0, 0, 0}
};
