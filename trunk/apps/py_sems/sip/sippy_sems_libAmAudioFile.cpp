/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.1.1 (4.1.1-255) on Mon Feb 19 14:57:35 2007
 */

#include "sipAPIpy_sems_lib.h"
#include "sippy_sems_libAmAudioFile.h"


static PyObject *meth_AmAudioFile_getLoop(PyObject *sipSelf,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
		AmAudioFile *sipCpp;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"m",sipSelf,sipClass_AmAudioFile,&sipCpp))
		{
			bool sipRes = 0;

#line 65 "AmAudio.sip"
	sipRes = sipCpp->loop.get();
#line 25 "sippy_sems_libAmAudioFile.cpp"

			return PyBool_FromLong(sipRes);
		}
	}

	/* Raise an exception if the arguments couldn't be parsed. */
	sipNoMethod(sipArgsParsed,sipNm_py_sems_lib_AmAudioFile,sipNm_py_sems_lib_getLoop);

	return NULL;
}


static PyObject *meth_AmAudioFile_setLoop(PyObject *sipSelf,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
		bool a0;
		AmAudioFile *sipCpp;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"mb",sipSelf,sipClass_AmAudioFile,&sipCpp,&a0))
		{
#line 70 "AmAudio.sip"
	sipCpp->loop.set(a0);
#line 50 "sippy_sems_libAmAudioFile.cpp"

			Py_INCREF(Py_None);
			return Py_None;
		}
	}

	/* Raise an exception if the arguments couldn't be parsed. */
	sipNoMethod(sipArgsParsed,sipNm_py_sems_lib_AmAudioFile,sipNm_py_sems_lib_setLoop);

	return NULL;
}


static PyObject *meth_AmAudioFile_open(PyObject *sipSelf,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
		const string * a0;
		int a0IsTemp = 0;
		AmAudioFile::OpenMode a1 = AmAudioFile::Read;
		bool a2 = 0;
		AmAudioFile *sipCpp;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"mM1|eb",sipSelf,sipClass_AmAudioFile,&sipCpp,sipConvertTo_string,&a0,&a0IsTemp,&a1,&a2))
		{
			int sipRes;

			sipRes = sipCpp -> AmAudioFile::open(*a0,a1,a2);

			if (a0IsTemp)
				delete const_cast<string *>(a0);

			return PyInt_FromLong((long)sipRes);
		}
	}

	/* Raise an exception if the arguments couldn't be parsed. */
	sipNoMethod(sipArgsParsed,sipNm_py_sems_lib_AmAudioFile,sipNm_py_sems_lib_open);

	return NULL;
}


static PyObject *meth_AmAudioFile_rewind(PyObject *sipSelf,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
		AmAudioFile *sipCpp;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"m",sipSelf,sipClass_AmAudioFile,&sipCpp))
		{
			sipCpp -> AmAudioFile::rewind();

			Py_INCREF(Py_None);
			return Py_None;
		}
	}

	/* Raise an exception if the arguments couldn't be parsed. */
	sipNoMethod(sipArgsParsed,sipNm_py_sems_lib_AmAudioFile,sipNm_py_sems_lib_rewind);

	return NULL;
}


static PyObject *meth_AmAudioFile_close(PyObject *sipSelf,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
		AmAudioFile *sipCpp;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"m",sipSelf,sipClass_AmAudioFile,&sipCpp))
		{
			sipCpp -> AmAudioFile::close();

			Py_INCREF(Py_None);
			return Py_None;
		}
	}

	/* Raise an exception if the arguments couldn't be parsed. */
	sipNoMethod(sipArgsParsed,sipNm_py_sems_lib_AmAudioFile,sipNm_py_sems_lib_close);

	return NULL;
}


static PyObject *meth_AmAudioFile_getDataSize(PyObject *sipSelf,PyObject *sipArgs)
{
	int sipArgsParsed = 0;

	{
		AmAudioFile *sipCpp;

		if (sipParseArgs(&sipArgsParsed,sipArgs,"m",sipSelf,sipClass_AmAudioFile,&sipCpp))
		{
			int sipRes;

			sipRes = sipCpp -> AmAudioFile::getDataSize();

			return PyInt_FromLong((long)sipRes);
		}
	}

	/* Raise an exception if the arguments couldn't be parsed. */
	sipNoMethod(sipArgsParsed,sipNm_py_sems_lib_AmAudioFile,sipNm_py_sems_lib_getDataSize);

	return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
static void *cast_AmAudioFile(void *ptr,sipWrapperType *targetClass)
{
	if (targetClass == sipClass_AmAudioFile)
		return ptr;

	return NULL;
}


static void dealloc_AmAudioFile(sipWrapper *sipSelf)
{
	if (sipIsPyOwned(sipSelf))
	{
		delete reinterpret_cast<AmAudioFile *>(sipSelf -> u.cppPtr);
	}
}


static void *init_AmAudioFile(sipWrapper *,PyObject *sipArgs,int *)
{
	int sipArgsParsed = 0;
	AmAudioFile *sipCpp = 0;

	if (!sipCpp)
	{
		if (sipParseArgs(&sipArgsParsed,sipArgs,""))
		{
			sipCpp = new AmAudioFile();
		}
	}

	if (!sipCpp)
	{
		sipNoCtor(sipArgsParsed,sipNm_py_sems_lib_AmAudioFile);
		return 0;
	}

	return sipCpp;
}


static void *forceConvertTo_AmAudioFile(PyObject *valobj,int *iserrp)
{
	if (*iserrp || valobj == NULL)
		return NULL;

	if (valobj == Py_None || sipIsSubClassInstance(valobj,sipClass_AmAudioFile))
		return sipConvertToCpp(valobj,sipClass_AmAudioFile,iserrp);

	sipBadClass(sipNm_py_sems_lib_AmAudioFile);

	*iserrp = 1;

	return NULL;
}


static PyMethodDef methods_AmAudioFile[] = {
	{sipNm_py_sems_lib_close, meth_AmAudioFile_close, METH_VARARGS, NULL},
	{sipNm_py_sems_lib_getDataSize, meth_AmAudioFile_getDataSize, METH_VARARGS, NULL},
	{sipNm_py_sems_lib_getLoop, meth_AmAudioFile_getLoop, METH_VARARGS, NULL},
	{sipNm_py_sems_lib_open, meth_AmAudioFile_open, METH_VARARGS, NULL},
	{sipNm_py_sems_lib_rewind, meth_AmAudioFile_rewind, METH_VARARGS, NULL},
	{sipNm_py_sems_lib_setLoop, meth_AmAudioFile_setLoop, METH_VARARGS, NULL}
};

static sipEnumValueInstanceDef enums_AmAudioFile[] = {
	{sipNm_py_sems_lib_Read, AmAudioFile::Read},
	{sipNm_py_sems_lib_Write, AmAudioFile::Write}
};


/* The main type data structure. */
sipTypeDef sipType_AmAudioFile = {
	0,
	"py_sems_lib.AmAudioFile",
	-1,
	0,
	0,
	6, methods_AmAudioFile,
	2, enums_AmAudioFile,
	0,
	init_AmAudioFile,
	dealloc_AmAudioFile,
	cast_AmAudioFile,
	forceConvertTo_AmAudioFile,
	0,
	0,
	0,
	{0, 0, 0, 0, 0, 0}
};
